// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/mauricelam/genny

package port

import (
	"fmt"

	"github.com/rs/xid"

	"reflect"

	"sync"
)

type OutputPortByte struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value byte
}

type InputPortByte struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     byte
	PrevValue byte
}

func NewOutputPortByte() *OutputPortByte {
	return &OutputPortByte{Mutex: sync.RWMutex{}}
}

func NewInputPortByte(blockingType BlockingType) *InputPortByte {
	return &InputPortByte{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortByte) GetID() xid.ID {
	return port.id
}

func (port *OutputPortByte) Write(value byte) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortByte) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortByte) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortByte) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortByte) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortByte) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortByte) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(byte)
	return nil
}

func (port *InputPortByte) Read() byte {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortInt struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value int
}

type InputPortInt struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     int
	PrevValue int
}

func NewOutputPortInt() *OutputPortInt {
	return &OutputPortInt{Mutex: sync.RWMutex{}}
}

func NewInputPortInt(blockingType BlockingType) *InputPortInt {
	return &InputPortInt{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortInt) GetID() xid.ID {
	return port.id
}

func (port *OutputPortInt) Write(value int) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortInt) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortInt) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortInt) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortInt) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortInt) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortInt) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(int)
	return nil
}

func (port *InputPortInt) Read() int {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortInt8 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value int8
}

type InputPortInt8 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     int8
	PrevValue int8
}

func NewOutputPortInt8() *OutputPortInt8 {
	return &OutputPortInt8{Mutex: sync.RWMutex{}}
}

func NewInputPortInt8(blockingType BlockingType) *InputPortInt8 {
	return &InputPortInt8{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortInt8) GetID() xid.ID {
	return port.id
}

func (port *OutputPortInt8) Write(value int8) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortInt8) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortInt8) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortInt8) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortInt8) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortInt8) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortInt8) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(int8)
	return nil
}

func (port *InputPortInt8) Read() int8 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortInt16 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value int16
}

type InputPortInt16 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     int16
	PrevValue int16
}

func NewOutputPortInt16() *OutputPortInt16 {
	return &OutputPortInt16{Mutex: sync.RWMutex{}}
}

func NewInputPortInt16(blockingType BlockingType) *InputPortInt16 {
	return &InputPortInt16{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortInt16) GetID() xid.ID {
	return port.id
}

func (port *OutputPortInt16) Write(value int16) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortInt16) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortInt16) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortInt16) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortInt16) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortInt16) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortInt16) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(int16)
	return nil
}

func (port *InputPortInt16) Read() int16 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortInt32 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value int32
}

type InputPortInt32 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     int32
	PrevValue int32
}

func NewOutputPortInt32() *OutputPortInt32 {
	return &OutputPortInt32{Mutex: sync.RWMutex{}}
}

func NewInputPortInt32(blockingType BlockingType) *InputPortInt32 {
	return &InputPortInt32{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortInt32) GetID() xid.ID {
	return port.id
}

func (port *OutputPortInt32) Write(value int32) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortInt32) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortInt32) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortInt32) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortInt32) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortInt32) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortInt32) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(int32)
	return nil
}

func (port *InputPortInt32) Read() int32 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortInt64 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value int64
}

type InputPortInt64 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     int64
	PrevValue int64
}

func NewOutputPortInt64() *OutputPortInt64 {
	return &OutputPortInt64{Mutex: sync.RWMutex{}}
}

func NewInputPortInt64(blockingType BlockingType) *InputPortInt64 {
	return &InputPortInt64{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortInt64) GetID() xid.ID {
	return port.id
}

func (port *OutputPortInt64) Write(value int64) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortInt64) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortInt64) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortInt64) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortInt64) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortInt64) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortInt64) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(int64)
	return nil
}

func (port *InputPortInt64) Read() int64 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortUint struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value uint
}

type InputPortUint struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     uint
	PrevValue uint
}

func NewOutputPortUint() *OutputPortUint {
	return &OutputPortUint{Mutex: sync.RWMutex{}}
}

func NewInputPortUint(blockingType BlockingType) *InputPortUint {
	return &InputPortUint{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortUint) GetID() xid.ID {
	return port.id
}

func (port *OutputPortUint) Write(value uint) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortUint) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortUint) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortUint) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortUint) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortUint) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortUint) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(uint)
	return nil
}

func (port *InputPortUint) Read() uint {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortUint8 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value uint8
}

type InputPortUint8 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     uint8
	PrevValue uint8
}

func NewOutputPortUint8() *OutputPortUint8 {
	return &OutputPortUint8{Mutex: sync.RWMutex{}}
}

func NewInputPortUint8(blockingType BlockingType) *InputPortUint8 {
	return &InputPortUint8{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortUint8) GetID() xid.ID {
	return port.id
}

func (port *OutputPortUint8) Write(value uint8) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortUint8) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortUint8) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortUint8) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortUint8) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortUint8) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortUint8) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(uint8)
	return nil
}

func (port *InputPortUint8) Read() uint8 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortUint16 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value uint16
}

type InputPortUint16 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     uint16
	PrevValue uint16
}

func NewOutputPortUint16() *OutputPortUint16 {
	return &OutputPortUint16{Mutex: sync.RWMutex{}}
}

func NewInputPortUint16(blockingType BlockingType) *InputPortUint16 {
	return &InputPortUint16{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortUint16) GetID() xid.ID {
	return port.id
}

func (port *OutputPortUint16) Write(value uint16) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortUint16) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortUint16) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortUint16) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortUint16) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortUint16) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortUint16) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(uint16)
	return nil
}

func (port *InputPortUint16) Read() uint16 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortUint32 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value uint32
}

type InputPortUint32 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     uint32
	PrevValue uint32
}

func NewOutputPortUint32() *OutputPortUint32 {
	return &OutputPortUint32{Mutex: sync.RWMutex{}}
}

func NewInputPortUint32(blockingType BlockingType) *InputPortUint32 {
	return &InputPortUint32{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortUint32) GetID() xid.ID {
	return port.id
}

func (port *OutputPortUint32) Write(value uint32) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortUint32) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortUint32) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortUint32) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortUint32) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortUint32) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortUint32) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(uint32)
	return nil
}

func (port *InputPortUint32) Read() uint32 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortUint64 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value uint64
}

type InputPortUint64 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     uint64
	PrevValue uint64
}

func NewOutputPortUint64() *OutputPortUint64 {
	return &OutputPortUint64{Mutex: sync.RWMutex{}}
}

func NewInputPortUint64(blockingType BlockingType) *InputPortUint64 {
	return &InputPortUint64{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortUint64) GetID() xid.ID {
	return port.id
}

func (port *OutputPortUint64) Write(value uint64) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortUint64) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortUint64) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortUint64) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortUint64) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortUint64) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortUint64) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(uint64)
	return nil
}

func (port *InputPortUint64) Read() uint64 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortBool struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value bool
}

type InputPortBool struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     bool
	PrevValue bool
}

func NewOutputPortBool() *OutputPortBool {
	return &OutputPortBool{Mutex: sync.RWMutex{}}
}

func NewInputPortBool(blockingType BlockingType) *InputPortBool {
	return &InputPortBool{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortBool) GetID() xid.ID {
	return port.id
}

func (port *OutputPortBool) Write(value bool) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortBool) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortBool) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortBool) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortBool) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortBool) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortBool) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(bool)
	return nil
}

func (port *InputPortBool) Read() bool {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortFloat32 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value float32
}

type InputPortFloat32 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     float32
	PrevValue float32
}

func NewOutputPortFloat32() *OutputPortFloat32 {
	return &OutputPortFloat32{Mutex: sync.RWMutex{}}
}

func NewInputPortFloat32(blockingType BlockingType) *InputPortFloat32 {
	return &InputPortFloat32{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortFloat32) GetID() xid.ID {
	return port.id
}

func (port *OutputPortFloat32) Write(value float32) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortFloat32) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortFloat32) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortFloat32) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortFloat32) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortFloat32) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortFloat32) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(float32)
	return nil
}

func (port *InputPortFloat32) Read() float32 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type OutputPortFloat64 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value float64
}

type InputPortFloat64 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     float64
	PrevValue float64
}

func NewOutputPortFloat64() *OutputPortFloat64 {
	return &OutputPortFloat64{Mutex: sync.RWMutex{}}
}

func NewInputPortFloat64(blockingType BlockingType) *InputPortFloat64 {
	return &InputPortFloat64{Mutex: sync.RWMutex{}, BaseInputPort: BaseInputPort{blockingType, false}}
}

func (port *OutputPortFloat64) GetID() xid.ID {
	return port.id
}

func (port *OutputPortFloat64) Write(value float64) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	port.Value = value
	port.id = xid.New()
	return nil
}

func (port *OutputPortFloat64) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *InputPortFloat64) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *InputPortFloat64) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *InputPortFloat64) ValueChanged() bool {
	return port.Value != port.PrevValue
}

func (port *InputPortFloat64) ValueNew() bool {
	return port.valueNew
}

func (port *InputPortFloat64) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}
	valueOfValue := reflect.ValueOf(value)
	port.PrevValue = port.Value
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().(float64)
	return nil
}

func (port *InputPortFloat64) Read() float64 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}
