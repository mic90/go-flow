// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/mauricelam/genny

package port

import (
	"errors"

	"fmt"

	"github.com/rs/xid"

	"reflect"

	"sync"
)

type ArrayOutputPortByte struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []byte
}

type ArrayInputPortByte struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []byte
	PrevValue []byte
}

func NewArrayOutputPortByte() *ArrayOutputPortByte {
	array := make([]byte, 10)
	return &ArrayOutputPortByte{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortByteLen(len int) *ArrayOutputPortByte {
	array := make([]byte, len)
	return &ArrayOutputPortByte{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortByte(blockingType BlockingType) *ArrayInputPortByte {
	array := make([]byte, 10)
	prevArray := make([]byte, 10)
	return &ArrayInputPortByte{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortByteLen(blockingType BlockingType, len int) *ArrayInputPortByte {
	array := make([]byte, len)
	prevArray := make([]byte, len)
	return &ArrayInputPortByte{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortByte) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortByte) Write(value []byte) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]byte, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortByte) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortByte) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortByte) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortByte) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortByte) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortByte) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]byte)
	return nil
}

func (port *ArrayInputPortByte) Read() []byte {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortInt struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []int
}

type ArrayInputPortInt struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []int
	PrevValue []int
}

func NewArrayOutputPortInt() *ArrayOutputPortInt {
	array := make([]int, 10)
	return &ArrayOutputPortInt{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortIntLen(len int) *ArrayOutputPortInt {
	array := make([]int, len)
	return &ArrayOutputPortInt{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortInt(blockingType BlockingType) *ArrayInputPortInt {
	array := make([]int, 10)
	prevArray := make([]int, 10)
	return &ArrayInputPortInt{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortIntLen(blockingType BlockingType, len int) *ArrayInputPortInt {
	array := make([]int, len)
	prevArray := make([]int, len)
	return &ArrayInputPortInt{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortInt) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortInt) Write(value []int) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]int, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortInt) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortInt) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortInt) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortInt) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortInt) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortInt) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]int)
	return nil
}

func (port *ArrayInputPortInt) Read() []int {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortInt8 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []int8
}

type ArrayInputPortInt8 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []int8
	PrevValue []int8
}

func NewArrayOutputPortInt8() *ArrayOutputPortInt8 {
	array := make([]int8, 10)
	return &ArrayOutputPortInt8{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortInt8Len(len int) *ArrayOutputPortInt8 {
	array := make([]int8, len)
	return &ArrayOutputPortInt8{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortInt8(blockingType BlockingType) *ArrayInputPortInt8 {
	array := make([]int8, 10)
	prevArray := make([]int8, 10)
	return &ArrayInputPortInt8{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortInt8Len(blockingType BlockingType, len int) *ArrayInputPortInt8 {
	array := make([]int8, len)
	prevArray := make([]int8, len)
	return &ArrayInputPortInt8{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortInt8) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortInt8) Write(value []int8) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]int8, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortInt8) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortInt8) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortInt8) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortInt8) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortInt8) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortInt8) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]int8)
	return nil
}

func (port *ArrayInputPortInt8) Read() []int8 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortInt16 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []int16
}

type ArrayInputPortInt16 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []int16
	PrevValue []int16
}

func NewArrayOutputPortInt16() *ArrayOutputPortInt16 {
	array := make([]int16, 10)
	return &ArrayOutputPortInt16{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortInt16Len(len int) *ArrayOutputPortInt16 {
	array := make([]int16, len)
	return &ArrayOutputPortInt16{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortInt16(blockingType BlockingType) *ArrayInputPortInt16 {
	array := make([]int16, 10)
	prevArray := make([]int16, 10)
	return &ArrayInputPortInt16{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortInt16Len(blockingType BlockingType, len int) *ArrayInputPortInt16 {
	array := make([]int16, len)
	prevArray := make([]int16, len)
	return &ArrayInputPortInt16{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortInt16) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortInt16) Write(value []int16) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]int16, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortInt16) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortInt16) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortInt16) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortInt16) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortInt16) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortInt16) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]int16)
	return nil
}

func (port *ArrayInputPortInt16) Read() []int16 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortInt32 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []int32
}

type ArrayInputPortInt32 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []int32
	PrevValue []int32
}

func NewArrayOutputPortInt32() *ArrayOutputPortInt32 {
	array := make([]int32, 10)
	return &ArrayOutputPortInt32{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortInt32Len(len int) *ArrayOutputPortInt32 {
	array := make([]int32, len)
	return &ArrayOutputPortInt32{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortInt32(blockingType BlockingType) *ArrayInputPortInt32 {
	array := make([]int32, 10)
	prevArray := make([]int32, 10)
	return &ArrayInputPortInt32{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortInt32Len(blockingType BlockingType, len int) *ArrayInputPortInt32 {
	array := make([]int32, len)
	prevArray := make([]int32, len)
	return &ArrayInputPortInt32{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortInt32) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortInt32) Write(value []int32) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]int32, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortInt32) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortInt32) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortInt32) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortInt32) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortInt32) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortInt32) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]int32)
	return nil
}

func (port *ArrayInputPortInt32) Read() []int32 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortInt64 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []int64
}

type ArrayInputPortInt64 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []int64
	PrevValue []int64
}

func NewArrayOutputPortInt64() *ArrayOutputPortInt64 {
	array := make([]int64, 10)
	return &ArrayOutputPortInt64{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortInt64Len(len int) *ArrayOutputPortInt64 {
	array := make([]int64, len)
	return &ArrayOutputPortInt64{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortInt64(blockingType BlockingType) *ArrayInputPortInt64 {
	array := make([]int64, 10)
	prevArray := make([]int64, 10)
	return &ArrayInputPortInt64{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortInt64Len(blockingType BlockingType, len int) *ArrayInputPortInt64 {
	array := make([]int64, len)
	prevArray := make([]int64, len)
	return &ArrayInputPortInt64{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortInt64) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortInt64) Write(value []int64) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]int64, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortInt64) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortInt64) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortInt64) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortInt64) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortInt64) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortInt64) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]int64)
	return nil
}

func (port *ArrayInputPortInt64) Read() []int64 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortUint struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []uint
}

type ArrayInputPortUint struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []uint
	PrevValue []uint
}

func NewArrayOutputPortUint() *ArrayOutputPortUint {
	array := make([]uint, 10)
	return &ArrayOutputPortUint{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortUintLen(len int) *ArrayOutputPortUint {
	array := make([]uint, len)
	return &ArrayOutputPortUint{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortUint(blockingType BlockingType) *ArrayInputPortUint {
	array := make([]uint, 10)
	prevArray := make([]uint, 10)
	return &ArrayInputPortUint{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortUintLen(blockingType BlockingType, len int) *ArrayInputPortUint {
	array := make([]uint, len)
	prevArray := make([]uint, len)
	return &ArrayInputPortUint{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortUint) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortUint) Write(value []uint) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]uint, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortUint) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortUint) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortUint) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortUint) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortUint) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortUint) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]uint)
	return nil
}

func (port *ArrayInputPortUint) Read() []uint {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortUint8 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []uint8
}

type ArrayInputPortUint8 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []uint8
	PrevValue []uint8
}

func NewArrayOutputPortUint8() *ArrayOutputPortUint8 {
	array := make([]uint8, 10)
	return &ArrayOutputPortUint8{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortUint8Len(len int) *ArrayOutputPortUint8 {
	array := make([]uint8, len)
	return &ArrayOutputPortUint8{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortUint8(blockingType BlockingType) *ArrayInputPortUint8 {
	array := make([]uint8, 10)
	prevArray := make([]uint8, 10)
	return &ArrayInputPortUint8{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortUint8Len(blockingType BlockingType, len int) *ArrayInputPortUint8 {
	array := make([]uint8, len)
	prevArray := make([]uint8, len)
	return &ArrayInputPortUint8{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortUint8) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortUint8) Write(value []uint8) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]uint8, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortUint8) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortUint8) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortUint8) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortUint8) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortUint8) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortUint8) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]uint8)
	return nil
}

func (port *ArrayInputPortUint8) Read() []uint8 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortUint16 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []uint16
}

type ArrayInputPortUint16 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []uint16
	PrevValue []uint16
}

func NewArrayOutputPortUint16() *ArrayOutputPortUint16 {
	array := make([]uint16, 10)
	return &ArrayOutputPortUint16{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortUint16Len(len int) *ArrayOutputPortUint16 {
	array := make([]uint16, len)
	return &ArrayOutputPortUint16{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortUint16(blockingType BlockingType) *ArrayInputPortUint16 {
	array := make([]uint16, 10)
	prevArray := make([]uint16, 10)
	return &ArrayInputPortUint16{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortUint16Len(blockingType BlockingType, len int) *ArrayInputPortUint16 {
	array := make([]uint16, len)
	prevArray := make([]uint16, len)
	return &ArrayInputPortUint16{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortUint16) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortUint16) Write(value []uint16) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]uint16, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortUint16) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortUint16) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortUint16) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortUint16) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortUint16) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortUint16) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]uint16)
	return nil
}

func (port *ArrayInputPortUint16) Read() []uint16 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortUint32 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []uint32
}

type ArrayInputPortUint32 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []uint32
	PrevValue []uint32
}

func NewArrayOutputPortUint32() *ArrayOutputPortUint32 {
	array := make([]uint32, 10)
	return &ArrayOutputPortUint32{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortUint32Len(len int) *ArrayOutputPortUint32 {
	array := make([]uint32, len)
	return &ArrayOutputPortUint32{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortUint32(blockingType BlockingType) *ArrayInputPortUint32 {
	array := make([]uint32, 10)
	prevArray := make([]uint32, 10)
	return &ArrayInputPortUint32{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortUint32Len(blockingType BlockingType, len int) *ArrayInputPortUint32 {
	array := make([]uint32, len)
	prevArray := make([]uint32, len)
	return &ArrayInputPortUint32{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortUint32) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortUint32) Write(value []uint32) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]uint32, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortUint32) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortUint32) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortUint32) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortUint32) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortUint32) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortUint32) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]uint32)
	return nil
}

func (port *ArrayInputPortUint32) Read() []uint32 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortUint64 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []uint64
}

type ArrayInputPortUint64 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []uint64
	PrevValue []uint64
}

func NewArrayOutputPortUint64() *ArrayOutputPortUint64 {
	array := make([]uint64, 10)
	return &ArrayOutputPortUint64{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortUint64Len(len int) *ArrayOutputPortUint64 {
	array := make([]uint64, len)
	return &ArrayOutputPortUint64{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortUint64(blockingType BlockingType) *ArrayInputPortUint64 {
	array := make([]uint64, 10)
	prevArray := make([]uint64, 10)
	return &ArrayInputPortUint64{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortUint64Len(blockingType BlockingType, len int) *ArrayInputPortUint64 {
	array := make([]uint64, len)
	prevArray := make([]uint64, len)
	return &ArrayInputPortUint64{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortUint64) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortUint64) Write(value []uint64) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]uint64, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortUint64) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortUint64) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortUint64) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortUint64) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortUint64) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortUint64) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]uint64)
	return nil
}

func (port *ArrayInputPortUint64) Read() []uint64 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortBool struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []bool
}

type ArrayInputPortBool struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []bool
	PrevValue []bool
}

func NewArrayOutputPortBool() *ArrayOutputPortBool {
	array := make([]bool, 10)
	return &ArrayOutputPortBool{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortBoolLen(len int) *ArrayOutputPortBool {
	array := make([]bool, len)
	return &ArrayOutputPortBool{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortBool(blockingType BlockingType) *ArrayInputPortBool {
	array := make([]bool, 10)
	prevArray := make([]bool, 10)
	return &ArrayInputPortBool{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortBoolLen(blockingType BlockingType, len int) *ArrayInputPortBool {
	array := make([]bool, len)
	prevArray := make([]bool, len)
	return &ArrayInputPortBool{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortBool) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortBool) Write(value []bool) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]bool, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortBool) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortBool) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortBool) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortBool) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortBool) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortBool) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]bool)
	return nil
}

func (port *ArrayInputPortBool) Read() []bool {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortFloat32 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []float32
}

type ArrayInputPortFloat32 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []float32
	PrevValue []float32
}

func NewArrayOutputPortFloat32() *ArrayOutputPortFloat32 {
	array := make([]float32, 10)
	return &ArrayOutputPortFloat32{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortFloat32Len(len int) *ArrayOutputPortFloat32 {
	array := make([]float32, len)
	return &ArrayOutputPortFloat32{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortFloat32(blockingType BlockingType) *ArrayInputPortFloat32 {
	array := make([]float32, 10)
	prevArray := make([]float32, 10)
	return &ArrayInputPortFloat32{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortFloat32Len(blockingType BlockingType, len int) *ArrayInputPortFloat32 {
	array := make([]float32, len)
	prevArray := make([]float32, len)
	return &ArrayInputPortFloat32{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortFloat32) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortFloat32) Write(value []float32) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]float32, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortFloat32) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortFloat32) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortFloat32) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortFloat32) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortFloat32) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortFloat32) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]float32)
	return nil
}

func (port *ArrayInputPortFloat32) Read() []float32 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}

type ArrayOutputPortFloat64 struct {
	BaseOutputPort
	Mutex sync.RWMutex
	Value []float64
}

type ArrayInputPortFloat64 struct {
	BaseInputPort
	Mutex     sync.RWMutex
	Value     []float64
	PrevValue []float64
}

func NewArrayOutputPortFloat64() *ArrayOutputPortFloat64 {
	array := make([]float64, 10)
	return &ArrayOutputPortFloat64{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayOutputPortFloat64Len(len int) *ArrayOutputPortFloat64 {
	array := make([]float64, len)
	return &ArrayOutputPortFloat64{BaseOutputPort: BaseOutputPort{}, Mutex: sync.RWMutex{}, Value: array}
}

func NewArrayInputPortFloat64(blockingType BlockingType) *ArrayInputPortFloat64 {
	array := make([]float64, 10)
	prevArray := make([]float64, 10)
	return &ArrayInputPortFloat64{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func NewArrayInputPortFloat64Len(blockingType BlockingType, len int) *ArrayInputPortFloat64 {
	array := make([]float64, len)
	prevArray := make([]float64, len)
	return &ArrayInputPortFloat64{BaseInputPort: BaseInputPort{blockingType, false}, Mutex: sync.RWMutex{}, Value: array, PrevValue: prevArray}
}

func (port *ArrayOutputPortFloat64) GetID() xid.ID {
	return port.id
}

// Write will write input slice value into the current port
// Input slice will be copied into internal port slice
// If internal port slice len is < input value it will be extended
func (port *ArrayOutputPortFloat64) Write(value []float64) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	if len(port.Value) < len(value) {
		port.Value = append(port.Value, make([]float64, len(value)-len(port.Value))...)
	}

	copy(port.Value, value)
	port.id = xid.New()
	return nil
}

func (port *ArrayInputPortFloat64) IsBlockingNew() bool {
	return port.blockingType == PortBlockingNew
}

func (port *ArrayInputPortFloat64) IsBlockingDiff() bool {
	return port.blockingType == PortBlockingDiff
}

func (port *ArrayInputPortFloat64) ValueChanged() bool {
	for i, value := range port.Value {
		if value != port.PrevValue[i] {
			return true
		}
	}
	return false
}

func (port *ArrayInputPortFloat64) ValueNew() bool {
	return port.valueNew
}

// read will return value currently stored in port
// Needed only for internal usage by graph
func (port *ArrayOutputPortFloat64) read() interface{} {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	return port.Value
}

func (port *ArrayInputPortFloat64) write(value interface{}) error {
	port.Mutex.Lock()
	defer port.Mutex.Unlock()

	typeOfValue := reflect.TypeOf(value)
	typeOfPortValue := reflect.TypeOf(port.Value)
	if typeOfValue.Kind() != reflect.Slice {
		return errors.New("unsupported value type, expected slice of values")
	}
	if !typeOfValue.ConvertibleTo(typeOfPortValue) {
		return fmt.Errorf("incompatible value types, given type: %v, could not be converted to: %v", typeOfValue, typeOfPortValue)
	}

	valueOfValue := reflect.ValueOf(value)
	copy(port.PrevValue, port.Value)
	port.valueNew = true
	port.Value = valueOfValue.Convert(typeOfPortValue).Interface().([]float64)
	return nil
}

func (port *ArrayInputPortFloat64) Read() []float64 {
	port.Mutex.RLock()
	defer port.Mutex.RUnlock()

	// reset value freshness on read
	port.valueNew = false

	return port.Value
}
